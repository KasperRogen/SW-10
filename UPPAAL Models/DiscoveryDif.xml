<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE nta PUBLIC '-//Uppaal Team//DTD Flat System 1.1//EN' 'http://www.it.uu.se/research/group/darts/uppaal/flat-1_2.dtd'>
<nta>
	<declaration>const int existingNodes = 4; // 
const int nrNewNodes = 1;
const int nodes = existingNodes + nrNewNodes;

clock time;

typedef struct { int a; int b; } edge;
typedef int[0, nodes - 1] UID;

int newNodes[nrNewNodes];
int newNodesNeighbour[nrNewNodes];
typedef int[0, nrNewNodes-1] startNodes;
int holeLink[2] = {-1, -1};

UID start; // The satellite that initiates

int[0, (3*nodes)] comms;

chan transmit[nodes];
broadcast chan ended;

meta UID sender;
meta UID neighbour;
meta int[0, nodes*2] len;
meta edge edgeList[nodes * 2];







</declaration>
	<template>
		<name>RingNodeSync</name>
		<parameter>const UID ID</parameter>
		<declaration>int[0, nodes * 2] verifyLen = 0;

clock t;

int[0, nodes*2] mapLen = 0;
int[0, nodes] newLen = 0;
edge networkMap[nodes*2];
edge newEdges[nodes];
UID seqNeighbour;
UID newNeighbour;

bool notifiedNewNode = false;
bool newKnowledge = false;


int IntClampExisting(int n)
{
  if (n &lt; 0) { return existingNodes - 1; }
  else { return n % existingNodes; }
}


bool IsNewNode()
{
  int i;
  for(i=0; i&lt;nrNewNodes; i++)
  {
    if (newNodes[i] == ID)
    {
      return true;
    }
  }
  return false;
}



void ExistingNetwork() 
{
  int i;

  if (IsNewNode())
  {
    return; // new nodes has no knowledge of the network
  }

  for(i=0; i&lt;existingNodes; i++)
  {
    int node1 = i;
    int node2 = IntClampExisting(i+1);
    edge newEdge = {node1, node2};

    if (i == ID)
    {
      seqNeighbour = node2;
    }

    networkMap[i] = newEdge;
    mapLen++;
  }
}


bool DiscoveredNewNode()
{
  int i;

  if (notifiedNewNode == true)
  {
    return false;
  }

  for(i=0; i&lt;nrNewNodes; i++)
  {
    if (newNodesNeighbour[i] == ID)
    {
      return true;
    }
  }
  return false;
}


void AddNewNodeNeighbour(int newNode)
{
  edge newEdge = {newNode, seqNeighbour};
  newEdges[newLen++] = newEdge;
  networkMap[mapLen++] = newEdge;
}


void UpdateNetworkMap()
{
  int i;
  for(i=0; i&lt;nrNewNodes; i++)
  {
    if (newNodesNeighbour[i] == ID)
    {
       edge newEdge = {ID, newNodes[i]};
       networkMap[mapLen++] = newEdge;

       newEdges[newLen++] = newEdge;

       newNeighbour = newNodes[i];

       AddNewNodeNeighbour(newNodes[i]);
    }
  }
}


// Checks if a edge is equal to another edge - {1,2} and {2,1} are considered equal.
bool EdgeEqual(edge e1, edge e2)
{
  return (e1.a == e2.a &amp;&amp; e1.b == e2.b) || (e1.a == e2.b &amp;&amp; e1.b == e2.a);
}

// Checks if a given edge already exists in the networkmap
bool ExistsInNetwork(edge e)
{
  int i;
  for (i=0; i&lt;mapLen; i++)
  {
    bool check = EdgeEqual(e, networkMap[i]);
    if (check == true) 
    {
      return true;
    } 
  }
  return false;
}


// Look at the transmitted edgeList, add all edges that this node didn't have knowledge about
void ProcessNewEdges()
{
  int i;
  newLen = 0;
  for (i=0; i&lt;len; i++)
  {
    edge e = edgeList[i];
    bool isNewEdge = !ExistsInNetwork(e);
    if (isNewEdge)
    {
      networkMap[mapLen++] = e;
      newEdges[newLen++] = e;
      newKnowledge = true;
    }
  }
}


// Reset the len variable and fills it with this nodes new edge knowledge
void TransmitNewEdges()
{
  int i;
  len = 0;
  for (i=0; i&lt;newLen; i++)
  {
    edgeList[len++] = newEdges[i];
  }
}


// Look at the transmitted edgeList, add all edges 
void ProcessAllEdges()
{
  int i;
  for (i=0; i&lt;len; i++)
  {
    networkMap[mapLen++] = edgeList[i];
  }
}


// Reset the edgeList and len variable and fills it with this nodes networkMap
void TransmitAllEdges()
{
  int i;
  len = 0;
  for (i=0; i&lt;mapLen; i++)
  {
    edgeList[len++] = networkMap[i];
  }
}


// Verification - Build the expected complete network map and check if they all exist in the node's network map
bool Verify()
{
  int i;

  // Check all start links
  for (i=0; i&lt;existingNodes; i++)
  {
    edge e = {i, IntClampExisting(i+1)};
    bool exist = ExistsInNetwork(e);
    
    if (exist == false) { return false; }
  }

  // Check all new links
  for (i=0; i&lt;nrNewNodes; i++)
  {
    edge e1 = {newNodesNeighbour[i], newNodes[i]};
    edge e2 = {newNodes[i], IntClampExisting(newNodesNeighbour[i] + 1)};

    bool exist1 = ExistsInNetwork(e1);
    bool exist2 = ExistsInNetwork(e2);

    if (!exist1 || !exist2) { return false; }
  }

  return true;
}
</declaration>
		<location id="id0" x="-102" y="340">
			<name x="-93" y="314">Receive</name>
		</location>
		<location id="id1" x="170" y="340">
			<name x="187" y="331">Discover</name>
			<urgent/>
		</location>
		<location id="id2" x="408" y="340">
			<name x="365" y="289">Transmit</name>
			<label kind="invariant" x="382" y="306">t &lt;= 1</label>
		</location>
		<location id="id3" x="-102" y="238">
			<name x="-85" y="238">Start</name>
			<committed/>
		</location>
		<location id="id4" x="-238" y="238">
			<name x="-221" y="238">Initialize</name>
			<urgent/>
		</location>
		<location id="id5" x="646" y="340">
			<committed/>
		</location>
		<location id="id6" x="170" y="170">
			<name x="110" y="119">UpdateNew</name>
			<label kind="invariant" x="144" y="136">t &lt;= 1</label>
		</location>
		<location id="id7" x="408" y="170">
			<name x="357" y="187">UpdateNeighbour</name>
			<committed/>
		</location>
		<location id="id8" x="-340" y="238">
			<name x="-425" y="221">NewNode</name>
		</location>
		<location id="id9" x="646" y="170">
			<committed/>
		</location>
		<location id="id10" x="-204" y="442">
			<committed/>
		</location>
		<location id="id11" x="-102" y="544">
			<name x="-127" y="561">ClearData</name>
			<committed/>
		</location>
		<location id="id12" x="-340" y="408">
			<name x="-365" y="374">Verified</name>
		</location>
		<location id="id13" x="-340" y="476">
			<name x="-365" y="493">Wrong</name>
		</location>
		<location id="id14" x="170" y="442">
			<name x="178" y="450">CheckNewKnowledge</name>
			<committed/>
		</location>
		<init ref="id4"/>
		<transition>
			<source ref="id14"/>
			<target ref="id10"/>
			<label kind="guard" x="59" y="459">!newKnowledge</label>
			<label kind="synchronisation" x="110" y="476">ended!</label>
			<nail x="170" y="612"/>
			<nail x="-204" y="612"/>
		</transition>
		<transition>
			<source ref="id1"/>
			<target ref="id14"/>
			<label kind="guard" x="178" y="374">!DiscoveredNewNode()</label>
		</transition>
		<transition>
			<source ref="id14"/>
			<target ref="id2"/>
			<label kind="guard" x="187" y="416">newKnowledge</label>
			<nail x="408" y="442"/>
		</transition>
		<transition>
			<source ref="id0"/>
			<target ref="id10"/>
			<label kind="synchronisation" x="-187" y="416">ended?</label>
			<nail x="-136" y="442"/>
		</transition>
		<transition>
			<source ref="id5"/>
			<target ref="id11"/>
			<nail x="646" y="544"/>
		</transition>
		<transition>
			<source ref="id10"/>
			<target ref="id13"/>
			<label kind="guard" x="-306" y="484">!Verify()</label>
			<nail x="-255" y="476"/>
		</transition>
		<transition>
			<source ref="id10"/>
			<target ref="id12"/>
			<label kind="guard" x="-306" y="382">Verify()</label>
			<nail x="-255" y="408"/>
		</transition>
		<transition>
			<source ref="id0"/>
			<target ref="id1"/>
			<label kind="synchronisation" x="0" y="297">transmit[ID]?</label>
			<label kind="assignment" x="-25" y="314">t = 0, ProcessNewEdges()</label>
		</transition>
		<transition>
			<source ref="id11"/>
			<target ref="id0"/>
			<label kind="assignment" x="-93" y="408">newKnowledge = false,
newLen = 0</label>
		</transition>
		<transition>
			<source ref="id9"/>
			<target ref="id5"/>
			<label kind="assignment" x="450" y="229">seqNeighbour = newNeighbour</label>
		</transition>
		<transition>
			<source ref="id7"/>
			<target ref="id9"/>
			<label kind="synchronisation" x="442" y="136">transmit[seqNeighbour]!</label>
			<label kind="assignment" x="425" y="111">TransmitNewEdges(), comms++</label>
		</transition>
		<transition>
			<source ref="id6"/>
			<target ref="id7"/>
			<label kind="guard" x="255" y="77">t &gt;= 1</label>
			<label kind="synchronisation" x="204" y="144">transmit[newNeighbour]!</label>
			<label kind="assignment" x="204" y="93">TransmitAllEdges(), comms++,
neighbour = seqNeighbour,
notifiedNewNode = true</label>
		</transition>
		<transition>
			<source ref="id8"/>
			<target ref="id0"/>
			<label kind="synchronisation" x="-331" y="263">transmit[ID]?</label>
			<label kind="assignment" x="-331" y="280">ProcessAllEdges(),
seqNeighbour = neighbour</label>
			<nail x="-340" y="340"/>
		</transition>
		<transition>
			<source ref="id4"/>
			<target ref="id8"/>
			<label kind="guard" x="-331" y="212">IsNewNode()</label>
		</transition>
		<transition>
			<source ref="id1"/>
			<target ref="id6"/>
			<label kind="guard" x="178" y="229">DiscoveredNewNode()</label>
			<label kind="assignment" x="178" y="246">UpdateNetworkMap()</label>
		</transition>
		<transition>
			<source ref="id3"/>
			<target ref="id1"/>
			<label kind="guard" x="-85" y="212">start == ID</label>
			<nail x="136" y="238"/>
		</transition>
		<transition>
			<source ref="id2"/>
			<target ref="id5"/>
			<label kind="guard" x="450" y="280">t &gt;= 1</label>
			<label kind="synchronisation" x="442" y="314">transmit[seqNeighbour]!</label>
			<label kind="assignment" x="425" y="297">TransmitNewEdges(), comms++</label>
		</transition>
		<transition>
			<source ref="id4"/>
			<target ref="id3"/>
			<label kind="guard" x="-212" y="195">!IsNewNode()</label>
			<label kind="assignment" x="-229" y="212">ExistingNetwork()</label>
		</transition>
		<transition>
			<source ref="id3"/>
			<target ref="id0"/>
			<label kind="guard" x="-93" y="289">start != ID</label>
		</transition>
	</template>
	<template>
		<name>TestRingNodeHole</name>
		<parameter>const UID ID</parameter>
		<declaration>int[0, nodes * 2] verifyLen = 0;

clock t;

int[0, nodes*2] mapLen = 0;
int[0, nodes] newLen = 0;
edge networkMap[nodes*2];
edge newEdges[nodes];

int senderID;

int cwNeighbour;
int ccwNeighbour;
int newNeighbour;

bool notifiedNewNode = false;
bool newKnowledge = false;


int IntClampExisting(int n)
{
  if (n &lt; 0) { return existingNodes - 1; }
  else { return n % existingNodes; }
}


int nextHop()
{
  return 1;
}


bool IsNewNode()
{
  int i;
  for(i=0; i&lt;nrNewNodes; i++)
  {
    if (newNodes[i] == ID)
    {
      return true;
    }
  }
  return false;
}


bool IsLinkBroken(int node1, int node2)
{
  if ((holeLink[0] == node1 &amp;&amp; holeLink[1] == node2) || (holeLink[0] == node2 &amp;&amp; holeLink[1] == node1))
  {
    return true;
  }
  else 
  {
    return false;
  }
}


void AddNeighbours()
{
  int cwNode = IntClampExisting(ID + 1);
  int ccwNode = IntClampExisting(ID - 1);

  if (!IsLinkBroken(ID, cwNode))
  {
    cwNeighbour = cwNode;
  }
  else
  {
    cwNeighbour = -1;
  }

  if (!IsLinkBroken(ID, ccwNode))
  {
    ccwNeighbour = ccwNode;
  }
  else
  {
    ccwNeighbour = -1;
  }
}

void ExistingNetwork() 
{
  int i;

  if (IsNewNode())
  {
    return; // new nodes has no knowledge of the network
  }

  for(i=0; i&lt;existingNodes; i++)
  {
    int node1 = i;
    int node2 = IntClampExisting(i+1);

    if (!IsLinkBroken(node1, node2))
    {
      edge newEdge = {node1, node2};
      networkMap[i] = newEdge;
      mapLen++;
    }
  }
}


bool DiscoveredNewNode()
{
  int i;

  if (notifiedNewNode == true)
  {
    return false;
  }

  for(i=0; i&lt;nrNewNodes; i++)
  {
    if (newNodesNeighbour[i] == ID)
    {
      return true;
    }
  }
  return false;
}


// If this node has a clockwise neighbour, adds an edge between the new node and the clockwise neighbour
void AddNewNodeNeighbour(int newNode)
{
  if (cwNeighbour != -1)
  {
    edge newEdge = {newNode, cwNeighbour};
    newEdges[newLen++] = newEdge;
    networkMap[mapLen++] = newEdge;
  }
}


// Adds a new edge between this node and the new node.
void UpdateNetworkMap()
{
  int i;
  for(i=0; i&lt;nrNewNodes; i++)
  {
    if (newNodesNeighbour[i] == ID)
    {
       edge newEdge = {ID, newNodes[i]};
       networkMap[mapLen++] = newEdge;

       newEdges[newLen++] = newEdge;

       newNeighbour = newNodes[i];

       AddNewNodeNeighbour(newNodes[i]);
    }
  }
}


// Checks if a edge is equal to another edge - {1,2} and {2,1} are considered equal.
bool EdgeEqual(edge e1, edge e2)
{
  return (e1.a == e2.a &amp;&amp; e1.b == e2.b) || (e1.a == e2.b &amp;&amp; e1.b == e2.a);
}

// Checks if a given edge already exists in the networkmap
bool ExistsInNetwork(edge e)
{
  int i;
  for (i=0; i&lt;mapLen; i++)
  {
    bool check = EdgeEqual(e, networkMap[i]);
    if (check == true) 
    {
      return true;
    } 
  }
  return false;
}


// Look at the transmitted edgeList, add all edges that this node didn't have knowledge about
void ProcessNewEdges()
{
  int i;
  newLen = 0;
  for (i=0; i&lt;len; i++)
  {
    edge e = edgeList[i];
    bool isNewEdge = !ExistsInNetwork(e);
    if (isNewEdge)
    {
      networkMap[mapLen++] = e;
      newEdges[newLen++] = e;
      newKnowledge = true;
    }
  }
}


// Reset the len variable and fills it with this nodes new edge knowledge
void TransmitNewEdges()
{
  int i;
  len = 0;
  for (i=0; i&lt;newLen; i++)
  {
    edgeList[len++] = newEdges[i];
  }
}


// Look at the transmitted edgeList, add all edges 
void ProcessAllEdges()
{
  int i;
  for (i=0; i&lt;len; i++)
  {
    networkMap[mapLen++] = edgeList[i];
  }
}


// Reset the edgeList and len variable and fills it with this nodes networkMap
void TransmitAllEdges()
{
  int i;
  len = 0;
  for (i=0; i&lt;mapLen; i++)
  {
    edgeList[len++] = networkMap[i];
  }
}


// Verification - Build the expected complete network map and check if they all exist in the node's network map
bool Verify()
{
  int i;

  // Check all start links
  for (i=0; i&lt;existingNodes; i++)
  {
    edge e = {i, IntClampExisting(i+1)};
    bool exist = ExistsInNetwork(e);
    
    if (exist == false) { return false; }
  }

  // Check all new links
  for (i=0; i&lt;nrNewNodes; i++)
  {
    edge e1 = {newNodesNeighbour[i], newNodes[i]};
    edge e2 = {newNodes[i], IntClampExisting(newNodesNeighbour[i] + 1)};

    bool exist1 = ExistsInNetwork(e1);
    bool exist2 = ExistsInNetwork(e2);

    if (!exist1 || !exist2) { return false; }
  }

  return true;
}
</declaration>
		<location id="id15" x="-102" y="340">
			<name x="-93" y="314">Receive</name>
		</location>
		<location id="id16" x="170" y="340">
			<name x="187" y="331">Discover</name>
			<urgent/>
		</location>
		<location id="id17" x="408" y="340">
			<name x="365" y="289">Transmit</name>
			<label kind="invariant" x="382" y="306">t &lt;= 1</label>
		</location>
		<location id="id18" x="-102" y="238">
			<name x="-85" y="238">Start</name>
			<committed/>
		</location>
		<location id="id19" x="-238" y="238">
			<name x="-221" y="238">Initialize</name>
			<urgent/>
		</location>
		<location id="id20" x="646" y="340">
			<committed/>
		</location>
		<location id="id21" x="170" y="170">
			<name x="110" y="119">UpdateNew</name>
			<label kind="invariant" x="144" y="136">t &lt;= 1</label>
		</location>
		<location id="id22" x="408" y="170">
			<name x="357" y="187">UpdateNeighbour</name>
			<committed/>
		</location>
		<location id="id23" x="-340" y="238">
			<name x="-425" y="221">NewNode</name>
		</location>
		<location id="id24" x="646" y="170">
			<committed/>
		</location>
		<location id="id25" x="-204" y="442">
			<committed/>
		</location>
		<location id="id26" x="-102" y="544">
			<name x="-127" y="561">ClearData</name>
			<committed/>
		</location>
		<location id="id27" x="-340" y="408">
			<name x="-365" y="374">Verified</name>
		</location>
		<location id="id28" x="-340" y="476">
			<name x="-365" y="493">Wrong</name>
		</location>
		<location id="id29" x="170" y="442">
			<name x="178" y="450">CheckNewKnowledge</name>
			<committed/>
		</location>
		<init ref="id19"/>
		<transition>
			<source ref="id29"/>
			<target ref="id25"/>
			<label kind="guard" x="59" y="459">!newKnowledge</label>
			<label kind="synchronisation" x="110" y="476">ended!</label>
			<nail x="170" y="612"/>
			<nail x="-204" y="612"/>
		</transition>
		<transition>
			<source ref="id16"/>
			<target ref="id29"/>
			<label kind="guard" x="178" y="374">!DiscoveredNewNode()</label>
		</transition>
		<transition>
			<source ref="id29"/>
			<target ref="id17"/>
			<label kind="guard" x="187" y="416">newKnowledge</label>
			<nail x="408" y="442"/>
		</transition>
		<transition>
			<source ref="id15"/>
			<target ref="id25"/>
			<label kind="synchronisation" x="-187" y="416">ended?</label>
			<nail x="-136" y="442"/>
		</transition>
		<transition>
			<source ref="id20"/>
			<target ref="id26"/>
			<nail x="646" y="544"/>
		</transition>
		<transition>
			<source ref="id25"/>
			<target ref="id28"/>
			<label kind="guard" x="-306" y="484">!Verify()</label>
			<nail x="-255" y="476"/>
		</transition>
		<transition>
			<source ref="id25"/>
			<target ref="id27"/>
			<label kind="guard" x="-306" y="382">Verify()</label>
			<nail x="-255" y="408"/>
		</transition>
		<transition>
			<source ref="id15"/>
			<target ref="id16"/>
			<label kind="synchronisation" x="0" y="280">transmit[ID]?</label>
			<label kind="assignment" x="-25" y="297">t = 0, senderID = sender,
ProcessNewEdges()</label>
		</transition>
		<transition>
			<source ref="id26"/>
			<target ref="id15"/>
			<label kind="assignment" x="-93" y="408">newKnowledge = false,
newLen = 0</label>
		</transition>
		<transition>
			<source ref="id24"/>
			<target ref="id20"/>
			<label kind="assignment" x="450" y="229">cwNeighbour = newNeighbour</label>
		</transition>
		<transition>
			<source ref="id22"/>
			<target ref="id24"/>
			<label kind="synchronisation" x="467" y="144">transmit[nextHop()]!</label>
			<label kind="assignment" x="425" y="119">TransmitNewEdges(), comms++</label>
		</transition>
		<transition>
			<source ref="id21"/>
			<target ref="id22"/>
			<label kind="guard" x="255" y="51">t &gt;= 1</label>
			<label kind="synchronisation" x="204" y="144">transmit[newNeighbour]!</label>
			<label kind="assignment" x="204" y="68">TransmitAllEdges(), comms++,
neighbour = cwNeighbour,
sender = ID,
notifiedNewNode = true</label>
		</transition>
		<transition>
			<source ref="id23"/>
			<target ref="id15"/>
			<label kind="synchronisation" x="-331" y="255">transmit[ID]?</label>
			<label kind="assignment" x="-331" y="272">ProcessAllEdges(),
cwNeighbour = neighbour,
ccwNeighbour = sender</label>
			<nail x="-340" y="340"/>
		</transition>
		<transition>
			<source ref="id19"/>
			<target ref="id23"/>
			<label kind="guard" x="-331" y="212">IsNewNode()</label>
		</transition>
		<transition>
			<source ref="id16"/>
			<target ref="id21"/>
			<label kind="guard" x="178" y="229">DiscoveredNewNode()</label>
			<label kind="assignment" x="178" y="246">UpdateNetworkMap()</label>
		</transition>
		<transition>
			<source ref="id18"/>
			<target ref="id16"/>
			<label kind="guard" x="-85" y="212">start == ID</label>
			<nail x="136" y="238"/>
		</transition>
		<transition>
			<source ref="id17"/>
			<target ref="id20"/>
			<label kind="guard" x="484" y="263">t &gt;= 1</label>
			<label kind="synchronisation" x="450" y="314">transmit[nextHop()]!</label>
			<label kind="assignment" x="442" y="280">TransmitNewEdges(),
sender = ID, comms++</label>
		</transition>
		<transition>
			<source ref="id19"/>
			<target ref="id18"/>
			<label kind="guard" x="-204" y="178">!IsNewNode()</label>
			<label kind="assignment" x="-221" y="195">ExistingNetwork(),
AddNeighbours()</label>
		</transition>
		<transition>
			<source ref="id18"/>
			<target ref="id15"/>
			<label kind="guard" x="-93" y="289">start != ID</label>
		</transition>
	</template>
	<template>
		<name>RingNodeAsync</name>
		<parameter>const UID ID</parameter>
		<declaration>int[0, nodes * 2] verifyLen = 0;

clock t;

int[0, nodes*2] mapLen = 0;
int[0, nodes] newLen = 0;
edge networkMap[nodes*2];
edge newEdges[nodes];
UID seqNeighbour;
UID newNeighbour;

bool notifiedNewNode = false;
bool newKnowledge = false;


int IntClampExisting(int n)
{
  if (n &lt; 0) { return existingNodes - 1; }
  else { return n % existingNodes; }
}


bool IsNewNode()
{
  int i;
  for(i=0; i&lt;nrNewNodes; i++)
  {
    if (newNodes[i] == ID)
    {
      return true;
    }
  }
  return false;
}



void ExistingNetwork() 
{
  int i;

  if (IsNewNode())
  {
    return; // new nodes has no knowledge of the network
  }

  for(i=0; i&lt;existingNodes; i++)
  {
    int node1 = i;
    int node2 = IntClampExisting(i+1);
    edge newEdge = {node1, node2};

    if (i == ID)
    {
      seqNeighbour = node2;
    }

    networkMap[i] = newEdge;
    mapLen++;
  }
}


bool DiscoveredNewNode()
{
  int i;

  if (notifiedNewNode == true)
  {
    return false;
  }

  for(i=0; i&lt;nrNewNodes; i++)
  {
    if (newNodesNeighbour[i] == ID)
    {
      return true;
    }
  }
  return false;
}


void AddNewNodeNeighbour(int newNode)
{
  edge newEdge = {newNode, seqNeighbour};
  newEdges[newLen++] = newEdge;
  networkMap[mapLen++] = newEdge;
}


void UpdateNetworkMap()
{
  int i;
  for(i=0; i&lt;nrNewNodes; i++)
  {
    if (newNodesNeighbour[i] == ID)
    {
       edge newEdge = {ID, newNodes[i]};
       networkMap[mapLen++] = newEdge;

       newEdges[newLen++] = newEdge;

       newNeighbour = newNodes[i];

       AddNewNodeNeighbour(newNodes[i]);
    }
  }
}


// Checks if a edge is equal to another edge - {1,2} and {2,1} are considered equal.
bool EdgeEqual(edge e1, edge e2)
{
  return (e1.a == e2.a &amp;&amp; e1.b == e2.b) || (e1.a == e2.b &amp;&amp; e1.b == e2.a);
}

// Checks if a given edge already exists in the networkmap
bool ExistsInNetwork(edge e)
{
  int i;
  for (i=0; i&lt;mapLen; i++)
  {
    bool check = EdgeEqual(e, networkMap[i]);
    if (check == true) 
    {
      return true;
    } 
  }
  return false;
}


// Look at the transmitted edgeList, add all edges that this node didn't have knowledge about
void ProcessNewEdges()
{
  int i;
  newLen = 0;
  for (i=0; i&lt;len; i++)
  {
    edge e = edgeList[i];
    bool isNewEdge = !ExistsInNetwork(e);
    if (isNewEdge)
    {
      networkMap[mapLen++] = e;
      newEdges[newLen++] = e;
      newKnowledge = true;
    }
  }
}


// Reset the len variable and fills it with this nodes new edge knowledge
void TransmitNewEdges()
{
  int i;
  len = 0;
  for (i=0; i&lt;newLen; i++)
  {
    edgeList[len++] = newEdges[i];
  }
}


// Look at the transmitted edgeList, add all edges 
void ProcessAllEdges()
{
  int i;
  for (i=0; i&lt;len; i++)
  {
    networkMap[mapLen++] = edgeList[i];
  }
}


// Reset the edgeList and len variable and fills it with this nodes networkMap
void TransmitAllEdges()
{
  int i;
  len = 0;
  for (i=0; i&lt;mapLen; i++)
  {
    edgeList[len++] = networkMap[i];
  }
}


// Verification - Build the expected complete network map and check if they all exist in the node's network map
bool Verify()
{
  int i;

  // Check all start links
  for (i=0; i&lt;existingNodes; i++)
  {
    edge e = {i, IntClampExisting(i+1)};
    bool exist = ExistsInNetwork(e);
    
    if (exist == false) { return false; }
  }

  // Check all new links
  for (i=0; i&lt;nrNewNodes; i++)
  {
    edge e1 = {newNodesNeighbour[i], newNodes[i]};
    edge e2 = {newNodes[i], IntClampExisting(newNodesNeighbour[i] + 1)};

    bool exist1 = ExistsInNetwork(e1);
    bool exist2 = ExistsInNetwork(e2);

    if (!exist1 || !exist2) { return false; }
  }

  return true;
}
</declaration>
		<location id="id30" x="612" y="340">
			<name x="620" y="348">CheckNewKnowledge</name>
			<committed/>
		</location>
		<location id="id31" x="238" y="340">
			<committed/>
		</location>
		<location id="id32" x="612" y="238">
			<name x="629" y="229">Discover</name>
			<urgent/>
		</location>
		<location id="id33" x="850" y="238">
			<name x="807" y="187">Transmit</name>
			<label kind="invariant" x="824" y="204">t &lt;= 10</label>
		</location>
		<location id="id34" x="340" y="238">
			<name x="349" y="212">Receive</name>
		</location>
		<location id="id35" x="1088" y="238">
			<committed/>
		</location>
		<location id="id36" x="340" y="442">
			<name x="315" y="459">ClearData</name>
			<committed/>
		</location>
		<location id="id37" x="102" y="374">
			<name x="77" y="391">Wrong</name>
		</location>
		<location id="id38" x="102" y="306">
			<name x="77" y="272">Verified</name>
		</location>
		<location id="id39" x="340" y="136">
			<name x="357" y="136">Start</name>
			<committed/>
		</location>
		<location id="id40" x="204" y="136">
			<name x="221" y="136">Initialize</name>
			<urgent/>
		</location>
		<location id="id41" x="612" y="68">
			<name x="552" y="17">UpdateNew</name>
			<label kind="invariant" x="586" y="34">t &lt;= 10</label>
		</location>
		<location id="id42" x="850" y="68">
			<name x="799" y="85">UpdateNeighbour</name>
			<committed/>
		</location>
		<location id="id43" x="102" y="136">
			<name x="17" y="119">NewNode</name>
		</location>
		<location id="id44" x="1088" y="68">
			<committed/>
		</location>
		<init ref="id40"/>
		<transition>
			<source ref="id30"/>
			<target ref="id31"/>
			<label kind="guard" x="501" y="357">!newKnowledge</label>
			<label kind="synchronisation" x="552" y="374">ended!</label>
			<nail x="612" y="510"/>
			<nail x="238" y="510"/>
		</transition>
		<transition>
			<source ref="id32"/>
			<target ref="id30"/>
			<label kind="guard" x="620" y="272">!DiscoveredNewNode()</label>
		</transition>
		<transition>
			<source ref="id30"/>
			<target ref="id33"/>
			<label kind="guard" x="629" y="314">newKnowledge</label>
			<nail x="850" y="340"/>
		</transition>
		<transition>
			<source ref="id34"/>
			<target ref="id31"/>
			<label kind="synchronisation" x="255" y="314">ended?</label>
			<nail x="306" y="340"/>
		</transition>
		<transition>
			<source ref="id35"/>
			<target ref="id36"/>
			<nail x="1088" y="442"/>
		</transition>
		<transition>
			<source ref="id31"/>
			<target ref="id37"/>
			<label kind="guard" x="136" y="382">!Verify()</label>
			<nail x="187" y="374"/>
		</transition>
		<transition>
			<source ref="id31"/>
			<target ref="id38"/>
			<label kind="guard" x="136" y="280">Verify()</label>
			<nail x="187" y="306"/>
		</transition>
		<transition>
			<source ref="id34"/>
			<target ref="id32"/>
			<label kind="synchronisation" x="442" y="195">transmit[ID]?</label>
			<label kind="assignment" x="417" y="212">t = 0, ProcessNewEdges()</label>
		</transition>
		<transition>
			<source ref="id36"/>
			<target ref="id34"/>
			<label kind="assignment" x="349" y="306">newKnowledge = false,
newLen = 0</label>
		</transition>
		<transition>
			<source ref="id44"/>
			<target ref="id35"/>
			<label kind="assignment" x="892" y="127">seqNeighbour = newNeighbour</label>
		</transition>
		<transition>
			<source ref="id42"/>
			<target ref="id44"/>
			<label kind="synchronisation" x="884" y="34">transmit[seqNeighbour]!</label>
			<label kind="assignment" x="867" y="9">TransmitNewEdges(), comms++</label>
		</transition>
		<transition>
			<source ref="id41"/>
			<target ref="id42"/>
			<label kind="guard" x="697" y="-25">t &gt;= 1</label>
			<label kind="synchronisation" x="646" y="42">transmit[newNeighbour]!</label>
			<label kind="assignment" x="646" y="-9">TransmitAllEdges(), comms++,
neighbour = seqNeighbour,
notifiedNewNode = true</label>
		</transition>
		<transition>
			<source ref="id43"/>
			<target ref="id34"/>
			<label kind="synchronisation" x="111" y="161">transmit[ID]?</label>
			<label kind="assignment" x="111" y="178">ProcessAllEdges(),
seqNeighbour = neighbour</label>
			<nail x="102" y="238"/>
		</transition>
		<transition>
			<source ref="id40"/>
			<target ref="id43"/>
			<label kind="guard" x="111" y="110">IsNewNode()</label>
		</transition>
		<transition>
			<source ref="id32"/>
			<target ref="id41"/>
			<label kind="guard" x="620" y="127">DiscoveredNewNode()</label>
			<label kind="assignment" x="620" y="144">UpdateNetworkMap()</label>
		</transition>
		<transition>
			<source ref="id39"/>
			<target ref="id32"/>
			<label kind="guard" x="357" y="110">start == ID</label>
			<nail x="578" y="136"/>
		</transition>
		<transition>
			<source ref="id33"/>
			<target ref="id35"/>
			<label kind="guard" x="892" y="178">t &gt;= 1</label>
			<label kind="synchronisation" x="884" y="212">transmit[seqNeighbour]!</label>
			<label kind="assignment" x="867" y="195">TransmitNewEdges(), comms++</label>
		</transition>
		<transition>
			<source ref="id40"/>
			<target ref="id39"/>
			<label kind="guard" x="230" y="93">!IsNewNode()</label>
			<label kind="assignment" x="213" y="110">ExistingNetwork()</label>
		</transition>
		<transition>
			<source ref="id39"/>
			<target ref="id34"/>
			<label kind="guard" x="349" y="187">start != ID</label>
		</transition>
	</template>
	<template>
		<name>Discovery</name>
		<declaration>int setup = 0;

int previousNeighbour = -1;

void AddNewNodes()
{
  int i;
  for(i=0; i&lt;nrNewNodes; i++)
  {
    newNodes[i] = existingNodes + i;
    newNodesNeighbour[i] = -1; // initialize
  }
}

bool HasNewNeighbour(int ID)
{

  int i;
  for(i=0; i&lt;nrNewNodes; i++)
  {
    if (newNodesNeighbour[i] == ID)
    {
      return true;
    }
  }
  return false;
}


bool IsNewNode(int node)
{
  int i;
  for(i=0; i&lt;nrNewNodes; i++)
  {
    if (newNodes[i] == node)
    {
      return true;
    }
  }
  return false;
}</declaration>
		<location id="id45" x="-382" y="0">
			<name x="-421" y="-34">ChooseStart</name>
			<committed/>
		</location>
		<location id="id46" x="-136" y="0">
			<name x="-146" y="-34">Done</name>
		</location>
		<location id="id47" x="-739" y="0">
			<name x="-751" y="-35">Init</name>
			<committed/>
		</location>
		<location id="id48" x="-586" y="0">
			<name x="-603" y="-34">Setup</name>
			<committed/>
		</location>
		<location id="id49" x="-646" y="102">
			<name x="-799" y="93">ChooseDiscoverNode</name>
			<committed/>
		</location>
		<init ref="id47"/>
		<transition>
			<source ref="id49"/>
			<target ref="id48"/>
			<label kind="select" x="-629" y="102">discovering : UID</label>
			<label kind="guard" x="-629" y="119">!HasNewNeighbour(discovering) &amp;&amp; !IsNewNode(discovering)</label>
			<label kind="assignment" x="-629" y="136">newNodesNeighbour[setup] = discovering,
setup++</label>
			<nail x="-510" y="102"/>
		</transition>
		<transition>
			<source ref="id48"/>
			<target ref="id45"/>
			<label kind="guard" x="-561" y="-25">setup == nrNewNodes</label>
			<nail x="-450" y="0"/>
		</transition>
		<transition>
			<source ref="id48"/>
			<target ref="id49"/>
			<label kind="guard" x="-756" y="34">setup &lt; nrNewNodes</label>
		</transition>
		<transition>
			<source ref="id47"/>
			<target ref="id48"/>
			<label kind="assignment" x="-716" y="-25">AddNewNodes()</label>
		</transition>
		<transition>
			<source ref="id45"/>
			<target ref="id46"/>
			<label kind="select" x="-289" y="-42">i : startNodes</label>
			<label kind="assignment" x="-340" y="-25">start = newNodesNeighbour[i]</label>
		</transition>
	</template>
	<template>
		<name>DiscoveryHole</name>
		<declaration>int setup = 0;

int previousNeighbour = -1;

void AddNewNodes()
{
  int i;
  for(i=0; i&lt;nrNewNodes; i++)
  {
    newNodes[i] = existingNodes + i;
    newNodesNeighbour[i] = -1; // initialize
  }
}

bool HasNewNeighbour(int ID)
{

  int i;
  for(i=0; i&lt;nrNewNodes; i++)
  {
    if (newNodesNeighbour[i] == ID)
    {
      return true;
    }
  }
  return false;
}


bool IsNewNode(int node)
{
  int i;
  for(i=0; i&lt;nrNewNodes; i++)
  {
    if (newNodes[i] == node)
    {
      return true;
    }
  }
  return false;
}


int IntClamp(int n)
{
  if (n &lt; 0) { return existingNodes - 1; }
  else { return n % existingNodes; }
}

void SetHole(int hole)
{
  int n2 = (hole + 1) % existingNodes;
  holeLink[0] = hole;
  holeLink[1] = n2;
}</declaration>
		<location id="id50" x="569" y="-170">
			<name x="535" y="-212">ChooseStart</name>
			<committed/>
		</location>
		<location id="id51" x="790" y="-170">
			<name x="780" y="-204">Done</name>
		</location>
		<location id="id52" x="42" y="-170">
			<name x="34" y="-212">Init</name>
			<committed/>
		</location>
		<location id="id53" x="195" y="-170">
			<name x="178" y="-212">Setup</name>
			<committed/>
		</location>
		<location id="id54" x="135" y="-68">
			<name x="-18" y="-77">ChooseDiscoverNode</name>
			<committed/>
		</location>
		<location id="id55" x="374" y="-170">
			<name x="331" y="-212">ChooseHole</name>
			<committed/>
		</location>
		<init ref="id52"/>
		<transition>
			<source ref="id55"/>
			<target ref="id50"/>
			<label kind="select" x="442" y="-221">hole : UID</label>
			<label kind="guard" x="416" y="-204">!IsNewNode(hole)</label>
			<label kind="assignment" x="433" y="-187">SetHole(hole)</label>
		</transition>
		<transition>
			<source ref="id53"/>
			<target ref="id55"/>
			<label kind="guard" x="212" y="-195">setup == nrNewNodes</label>
		</transition>
		<transition>
			<source ref="id54"/>
			<target ref="id53"/>
			<label kind="select" x="152" y="-68">discovering : UID</label>
			<label kind="guard" x="152" y="-51">!HasNewNeighbour(discovering) &amp;&amp; !IsNewNode(discovering)</label>
			<label kind="assignment" x="152" y="-34">newNodesNeighbour[setup] = discovering,
setup++</label>
			<nail x="271" y="-68"/>
		</transition>
		<transition>
			<source ref="id53"/>
			<target ref="id54"/>
			<label kind="guard" x="25" y="-136">setup &lt; nrNewNodes</label>
		</transition>
		<transition>
			<source ref="id52"/>
			<target ref="id53"/>
			<label kind="assignment" x="65" y="-195">AddNewNodes()</label>
		</transition>
		<transition>
			<source ref="id50"/>
			<target ref="id51"/>
			<label kind="select" x="637" y="-204">i : startNodes</label>
			<label kind="assignment" x="586" y="-187">start = newNodesNeighbour[i]</label>
		</transition>
	</template>
	<system>system RingNodeSync, DiscoveryHole;</system>
	<queries>
		<query>
			<formula>***** SYNC QUERIES *****</formula>
			<comment></comment>
		</query>
		<query>
			<formula></formula>
			<comment></comment>
		</query>
		<query>
			<formula>A&lt;&gt; forall (i : UID) RingNodeSync(i).Verified &amp;&amp; time &lt;= (nodes * 2) - nrNewNodes</formula>
			<comment></comment>
		</query>
		<query>
			<formula>A&lt;&gt; forall (i : UID) RingNodeSync(i).Verified &amp;&amp; time &lt;= (nodes * 2) - nrNewNodes - 1</formula>
			<comment></comment>
		</query>
		<query>
			<formula></formula>
			<comment></comment>
		</query>
		<query>
			<formula>A&lt;&gt; forall (i : UID) RingNodeSync(i).Verified</formula>
			<comment></comment>
		</query>
		<query>
			<formula></formula>
			<comment></comment>
		</query>
		<query>
			<formula>A&lt;&gt; forall (i : UID) RingNodeSync(i).Wrong || RingNodeSync(i).Verified</formula>
			<comment></comment>
		</query>
		<query>
			<formula></formula>
			<comment></comment>
		</query>
		<query>
			<formula>A[] comms &lt;= nodes * 2 - 2</formula>
			<comment></comment>
		</query>
		<query>
			<formula>A[] comms &lt;= (nodes * 2) - 3</formula>
			<comment></comment>
		</query>
		<query>
			<formula></formula>
			<comment></comment>
		</query>
		<query>
			<formula>* One New Node</formula>
			<comment></comment>
		</query>
		<query>
			<formula>A[] comms &lt;= nodes</formula>
			<comment></comment>
		</query>
		<query>
			<formula>E&lt;&gt; comms - 1 &lt;= nodes &amp;&amp; (forall (i : UID) RingNodeSync(i).Verified || RingNodeSync(i).Wrong)</formula>
			<comment></comment>
		</query>
		<query>
			<formula></formula>
			<comment></comment>
		</query>
		<query>
			<formula>***** ASYNC QUERIES *****</formula>
			<comment></comment>
		</query>
		<query>
			<formula></formula>
			<comment></comment>
		</query>
		<query>
			<formula>A&lt;&gt; forall (i : UID) RingNodeAsync(i).Verified</formula>
			<comment></comment>
		</query>
		<query>
			<formula></formula>
			<comment></comment>
		</query>
		<query>
			<formula>A&lt;&gt; forall (i : UID) RingNodeAsync(i).Wrong || RingNodeAsync(i).Verified</formula>
			<comment></comment>
		</query>
		<query>
			<formula></formula>
			<comment></comment>
		</query>
		<query>
			<formula>A[] comms &lt;= nodes * 2</formula>
			<comment></comment>
		</query>
		<query>
			<formula>A[] comms &lt;= (nodes * 2) -1</formula>
			<comment></comment>
		</query>
		<query>
			<formula>E&lt;&gt; forall (i : UID) RingNodeAsync(i).Verified &amp;&amp; comms &lt;= (nodes * 2) - 1</formula>
			<comment></comment>
		</query>
		<query>
			<formula></formula>
			<comment></comment>
		</query>
		<query>
			<formula></formula>
			<comment></comment>
		</query>
		<query>
			<formula>***** DEBUG QUERIES *****</formula>
			<comment></comment>
		</query>
		<query>
			<formula></formula>
			<comment></comment>
		</query>
		<query>
			<formula>E&lt;&gt; deadlock</formula>
			<comment></comment>
		</query>
		<query>
			<formula>E&lt;&gt; deadlock &amp;&amp; (forall (i: UID) !RingNodeSync(i).Wrong &amp;&amp; !RingNodeSync(i).Verified)</formula>
			<comment></comment>
		</query>
		<query>
			<formula>E&lt;&gt; deadlock &amp;&amp; (forall (i: UID) !RingNodeAsync(i).Wrong &amp;&amp; !RingNodeAsync(i).Verified)</formula>
			<comment></comment>
		</query>
		<query>
			<formula></formula>
			<comment></comment>
		</query>
		<query>
			<formula>E&lt;&gt; exists (i : UID) RingNodeSync(i).Wrong</formula>
			<comment></comment>
		</query>
		<query>
			<formula>E&lt;&gt; exists (i : UID) RingNodeAsync(i).Wrong</formula>
			<comment></comment>
		</query>
		<query>
			<formula></formula>
			<comment></comment>
		</query>
		<query>
			<formula>E&lt;&gt; forall (i : UID) RingNodeSync(i).Verified</formula>
			<comment></comment>
		</query>
		<query>
			<formula>E&lt;&gt; forall (i : UID) RingNodeAsync(i).Verified</formula>
			<comment></comment>
		</query>
		<query>
			<formula></formula>
			<comment>Tjekker deadlock. Er opfyldt da systemet er deadlocked n√•r alle noder er Verified</comment>
		</query>
	</queries>
</nta>
