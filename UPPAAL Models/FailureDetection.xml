<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE nta PUBLIC '-//Uppaal Team//DTD Flat System 1.1//EN' 'http://www.it.uu.se/research/group/darts/uppaal/flat-1_2.dtd'>
<nta>
	<declaration>// Place global declarations here.
const int N = 30;

clock time;
int[0, 2*N] comms;
int[0, 6*N] totalFailures;

typedef int[0, N-1] UID;

broadcast chan transmit[N];
broadcast chan respond[N];


UID start;

bool subdivided;
bool singleSplit;
bool split;

const int len = 2;
int deadNodes[len] = {-1, -1};

meta UID sender;
meta UID failedNode;
meta bool isFailed;


</declaration>
	<template>
		<name x="5" y="5">RingNodeSync</name>
		<parameter>const UID ID</parameter>
		<declaration>clock t;

UID senderID;
UID failedNodeID;
UID firstFailID;

bool sndPass = false;
bool newFailure;

int tolerance = 3;
int[0,3] failures = 0;



UID Clockwise(int n)
{
  return n % N;
}


UID CounterClockwise(int n)
{
  if (n &lt; 0) { return N - 1; }
  else { return n; }

}


UID cwHop(){
  return Clockwise(ID + 1);
}


UID ccwHop()
{
  return CounterClockwise(ID - 1);
}



UID nextHop()
{
  if (senderID == cwHop())
  {
    return ccwHop();
  }
  else
  {
    return cwHop();
  }
}


bool isDead()
{
  int i;
  
  if (deadNodes[0] == ID)
  {
    return true;
  }
  else if (singleSplit == false &amp;&amp; deadNodes[1] == ID)
  {
    return true;
  }
  else
  {
    return false;
  }
}


// "Walks" from the first dead node to the second dead node and checks if its between the two dead nodes.
bool isOutOfReach()
{
  int i;
  int node = deadNodes[0];

  if ( subdivided == false )
  {
    return false;
  }

  for (i = 0; i &lt; N; i++)
  {
    node = Clockwise(node + 1);
    if (node == deadNodes[1])
    { 
      return false;
    }
    else if (node == ID)
    {
      return true;
    }
  }
  return false;
}


// Compares the failed node received in the first transmission to the one just received.
// On first tranmission, stores the failed node.
void CheckFailed()
{
  if (sndPass == true)
  {
    if (failedNodeID != firstFailID)
    {
      newFailure = true;
    }
  }
  else
  {
    firstFailID = failedNodeID;
  }
}



bool isSubdivided()
{
  if (newFailure == false)
  {
    return false;
  }
  else
  {
    UID neighbour1 = Clockwise(failedNodeID + 1);
    UID neighbour2 = CounterClockwise(failedNodeID - 1);

    return (firstFailID != neighbour1 &amp;&amp; firstFailID != neighbour2);
  }
}
</declaration>
		<location id="id0" x="-408" y="-68">
			<name x="-433" y="-102">Init</name>
			<urgent/>
		</location>
		<location id="id1" x="-408" y="68">
			<name x="-399" y="42">Receive</name>
		</location>
		<location id="id2" x="-68" y="68">
			<name x="-59" y="25">Transmit</name>
			<label kind="invariant" x="-57" y="42">t &lt;= 1</label>
		</location>
		<location id="id3" x="-238" y="68">
			<name x="-263" y="34">Respond</name>
			<committed/>
		</location>
		<location id="id4" x="136" y="-34">
			<name x="119" y="-76">Retry</name>
			<committed/>
		</location>
		<location id="id5" x="136" y="68">
			<name x="102" y="76">Response</name>
			<label kind="invariant" x="119" y="93">t &lt;= 1</label>
		</location>
		<location id="id6" x="306" y="-34">
			<name x="272" y="-25">FailedTrans</name>
			<label kind="invariant" x="289" y="-8">t &lt;= 1</label>
		</location>
		<location id="id7" x="-408" y="-170">
			<name x="-425" y="-204">Dead</name>
		</location>
		<location id="id8" x="-569" y="68">
			<name x="-560" y="42">Start</name>
			<label kind="invariant" x="-561" y="25">t &lt;= 1</label>
		</location>
		<location id="id9" x="-408" y="204">
			<committed/>
		</location>
		<location id="id10" x="306" y="68">
			<committed/>
		</location>
		<location id="id11" x="450" y="68">
			<name x="467" y="59">Done</name>
			<committed/>
		</location>
		<location id="id12" x="416" y="187">
			<name x="399" y="204">Split</name>
		</location>
		<location id="id13" x="484" y="187">
			<name x="450" y="204">Subdivided</name>
		</location>
		<location id="id14" x="-238" y="-68">
			<name x="-221" y="-76">OutOfReach</name>
		</location>
		<init ref="id0"/>
		<transition>
			<source ref="id11"/>
			<target ref="id13"/>
			<label kind="guard" x="489" y="130">isSubdivided()</label>
			<nail x="484" y="93"/>
		</transition>
		<transition>
			<source ref="id11"/>
			<target ref="id12"/>
			<label kind="guard" x="317" y="127">!isSubdivided()</label>
			<nail x="416" y="96"/>
		</transition>
		<transition>
			<source ref="id0"/>
			<target ref="id14"/>
			<label kind="guard" x="-399" y="-93">isOutOfReach() == true</label>
		</transition>
		<transition>
			<source ref="id2"/>
			<target ref="id10"/>
			<label kind="guard" x="80" y="170">start == ID</label>
			<nail x="-68" y="170"/>
			<nail x="272" y="170"/>
		</transition>
		<transition>
			<source ref="id10"/>
			<target ref="id11"/>
			<label kind="guard" x="323" y="34">sndPass == true</label>
		</transition>
		<transition>
			<source ref="id6"/>
			<target ref="id11"/>
			<label kind="guard" x="341" y="-183">t &gt;= 1</label>
			<label kind="synchronisation" x="340" y="-69">transmit[senderID]!</label>
			<label kind="assignment" x="340" y="-164">sender = ID,
failedNode = nextHop(),
failedNodeID = nextHop(),
CheckFailed(),
comms++</label>
			<nail x="450" y="-34"/>
		</transition>
		<transition>
			<source ref="id10"/>
			<target ref="id9"/>
			<label kind="guard" x="-136" y="204">sndPass == false</label>
			<nail x="306" y="204"/>
		</transition>
		<transition>
			<source ref="id5"/>
			<target ref="id10"/>
			<label kind="synchronisation" x="187" y="68">respond[ID]?</label>
			<label kind="assignment" x="187" y="85">failures = 0,
comms++</label>
		</transition>
		<transition>
			<source ref="id9"/>
			<target ref="id1"/>
			<label kind="assignment" x="-399" y="161">sndPass = true</label>
		</transition>
		<transition>
			<source ref="id8"/>
			<target ref="id1"/>
			<label kind="guard" x="-527" y="68">t &gt;= 1</label>
			<label kind="synchronisation" x="-561" y="85">transmit[ccwHop()]!</label>
			<label kind="assignment" x="-561" y="102">sender = ID,
firstFailID = cwHop(),
failedNode = cwHop(),
sndPass = true,
comms++</label>
		</transition>
		<transition>
			<source ref="id0"/>
			<target ref="id8"/>
			<label kind="guard" x="-535" y="-102">start == ID</label>
			<label kind="assignment" x="-518" y="-85">t = 0</label>
			<nail x="-569" y="-68"/>
		</transition>
		<transition>
			<source ref="id4"/>
			<target ref="id6"/>
			<label kind="guard" x="157" y="-59">failures &gt;= tolerance</label>
			<label kind="assignment" x="157" y="-94">t = 0,
sndPass  = true</label>
		</transition>
		<transition>
			<source ref="id4"/>
			<target ref="id2"/>
			<label kind="guard" x="-51" y="-59">failures &lt; tolerance</label>
			<nail x="-68" y="-34"/>
		</transition>
		<transition>
			<source ref="id2"/>
			<target ref="id5"/>
			<label kind="guard" x="-51" y="68">t &gt;= 1 &amp;&amp; start != ID</label>
			<label kind="synchronisation" x="-51" y="85">transmit[nextHop()]!</label>
			<label kind="assignment" x="-51" y="102">sender = ID,
failedNode = failedNodeID,
t = 0</label>
		</transition>
		<transition>
			<source ref="id0"/>
			<target ref="id7"/>
			<label kind="guard" x="-403" y="-134">isDead() == true</label>
		</transition>
		<transition>
			<source ref="id5"/>
			<target ref="id4"/>
			<label kind="guard" x="144" y="-17">t &gt;= 1</label>
			<label kind="assignment" x="144" y="0">failures++,
totalFailures++</label>
		</transition>
		<transition>
			<source ref="id3"/>
			<target ref="id2"/>
			<label kind="synchronisation" x="-212" y="68">respond[senderID]!</label>
			<label kind="assignment" x="-178" y="85">t = 0</label>
		</transition>
		<transition>
			<source ref="id1"/>
			<target ref="id3"/>
			<label kind="synchronisation" x="-374" y="68">transmit[ID]?</label>
			<label kind="assignment" x="-374" y="85">senderID = sender,
failedNodeID = failedNode,
CheckFailed()</label>
		</transition>
		<transition>
			<source ref="id0"/>
			<target ref="id1"/>
			<label kind="guard" x="-403" y="-31">start != ID &amp;&amp;
isDead() == false &amp;&amp;
isOutOfReach() == false</label>
		</transition>
	</template>
	<template>
		<name>RingNodeAsync</name>
		<parameter>const UID ID</parameter>
		<declaration>clock t;

UID senderID;
UID failedNodeID;
UID firstFailID;

bool sndPass = false;
bool newFailure;

int tolerance = 3;
int[0,3] failures = 0;

UID Clockwise(int n)
{
  return n % N;
}

UID CounterClockwise(int n)
{
  if (n &lt; 0) { return N - 1; }
  else { return n; }

}

UID cwHop(){
  return Clockwise(ID + 1);
}

UID ccwHop()
{
  return CounterClockwise(ID - 1);
}

UID nextHop()
{
  if (senderID == cwHop())
  {
    return ccwHop();
  }
  else
  {
    return cwHop();
  }
}


bool isDead()
{
  int i;
  
  if (deadNodes[0] == ID)
  {
    return true;
  }
  else if (singleSplit == false &amp;&amp; deadNodes[1] == ID)
  {
    return true;
  }
  else
  {
    return false;
  }
}


bool isOutOfReach()
{
  int i;
  int node = deadNodes[0];

  if ( subdivided == false )
  {
    return false;
  }

  for (i = 0; i &lt; N; i++)
  {
    node = Clockwise(node + 1);
    if (node == deadNodes[1])
    { 
      return false;
    }
    else if (node == ID)
    {
      return true;
    }
  }
  return false;
}


// Compares the failed node received in the first transmission to the one just received.
// On first tranmission, stores the failed node
void CheckFailed()
{
  if (sndPass == true &amp;&amp; failedNodeID != failedNode)
  {
    newFailure = true;
    firstFailID = failedNodeID;
  }
  failedNodeID = failedNode;
}


bool isSubdivided()
{
  if (newFailure == false)
  {
    return false;
  }
  else
  {
    UID neighbour1 = Clockwise(failedNodeID + 1);
    UID neighbour2 = CounterClockwise(failedNodeID - 1);

    return (firstFailID != neighbour1 &amp;&amp; firstFailID != neighbour2);
  }
}</declaration>
		<location id="id15" x="-510" y="-34">
			<name x="-535" y="-68">Init</name>
			<urgent/>
		</location>
		<location id="id16" x="-340" y="-34">
			<name x="-323" y="-42">OutOfReach</name>
		</location>
		<location id="id17" x="-510" y="102">
			<name x="-501" y="76">Receive</name>
		</location>
		<location id="id18" x="-170" y="102">
			<name x="-167" y="57">Transmit</name>
			<label kind="invariant" x="-164" y="72">t &lt;= 10</label>
		</location>
		<location id="id19" x="-340" y="102">
			<name x="-366" y="58">Respond</name>
			<label kind="invariant" x="-361" y="73">t &lt;= 15</label>
		</location>
		<location id="id20" x="34" y="0">
			<name x="9" y="-42">Retry</name>
			<committed/>
		</location>
		<location id="id21" x="34" y="102">
			<name x="8" y="110">Response</name>
			<label kind="invariant" x="17" y="127">t &lt;= 5</label>
		</location>
		<location id="id22" x="204" y="0">
			<name x="170" y="12">FailedTrans</name>
			<label kind="invariant" x="185" y="27">t &lt;= 10</label>
		</location>
		<location id="id23" x="-510" y="-136">
			<name x="-527" y="-170">Dead</name>
		</location>
		<location id="id24" x="-663" y="102">
			<name x="-654" y="76">Start</name>
			<label kind="invariant" x="-654" y="59">t &lt;= 1</label>
		</location>
		<location id="id25" x="-510" y="272">
			<committed/>
		</location>
		<location id="id26" x="204" y="102">
			<committed/>
		</location>
		<location id="id27" x="348" y="102">
			<name x="365" y="94">Done</name>
			<committed/>
		</location>
		<location id="id28" x="314" y="187">
			<name x="297" y="204">Split</name>
		</location>
		<location id="id29" x="382" y="187">
			<name x="348" y="204">Subdivided</name>
		</location>
		<init ref="id15"/>
		<transition>
			<source ref="id18"/>
			<target ref="id26"/>
			<label kind="synchronisation" x="-28" y="170">respond[ID]?</label>
			<label kind="assignment" x="-25" y="185">failures = 0</label>
			<nail x="-136" y="204"/>
			<nail x="136" y="204"/>
		</transition>
		<transition>
			<source ref="id15"/>
			<target ref="id16"/>
			<label kind="guard" x="-501" y="-59">isOutOfReach() == true</label>
		</transition>
		<transition>
			<source ref="id18"/>
			<target ref="id26"/>
			<label kind="guard" x="-22" y="237">start == ID</label>
			<nail x="-170" y="238"/>
			<nail x="170" y="238"/>
		</transition>
		<transition>
			<source ref="id27"/>
			<target ref="id29"/>
			<label kind="guard" x="386" y="132">isSubdivided()</label>
			<nail x="357" y="127"/>
			<nail x="382" y="127"/>
		</transition>
		<transition>
			<source ref="id27"/>
			<target ref="id28"/>
			<label kind="guard" x="212" y="136">!isSubdivided()</label>
			<nail x="340" y="127"/>
			<nail x="314" y="127"/>
		</transition>
		<transition>
			<source ref="id26"/>
			<target ref="id27"/>
			<label kind="guard" x="221" y="76">sndPass == true</label>
		</transition>
		<transition>
			<source ref="id22"/>
			<target ref="id27"/>
			<label kind="guard" x="229" y="-153">t &gt;= 1</label>
			<label kind="synchronisation" x="229" y="-136">transmit[senderID]!</label>
			<label kind="assignment" x="229" y="-119">sender = ID,
failedNode = nextHop(),
newFailure = true,
firstFailID = failedNodeID,
failedNodeID = nextHop(),
comms++</label>
			<nail x="348" y="0"/>
		</transition>
		<transition>
			<source ref="id26"/>
			<target ref="id25"/>
			<label kind="guard" x="-229" y="272">sndPass == false</label>
			<nail x="204" y="272"/>
		</transition>
		<transition>
			<source ref="id21"/>
			<target ref="id26"/>
			<label kind="synchronisation" x="84" y="102">respond[ID]?</label>
			<label kind="assignment" x="84" y="119">failures = 0,
comms++</label>
		</transition>
		<transition>
			<source ref="id25"/>
			<target ref="id17"/>
			<label kind="assignment" x="-501" y="229">sndPass = true</label>
		</transition>
		<transition>
			<source ref="id24"/>
			<target ref="id17"/>
			<label kind="guard" x="-629" y="102">t &gt;= 1</label>
			<label kind="synchronisation" x="-663" y="119">transmit[ccwHop()]!</label>
			<label kind="assignment" x="-663" y="136">sender = ID,
failedNodeID = cwHop(),
failedNode = cwHop(),
sndPass = true,
comms++</label>
		</transition>
		<transition>
			<source ref="id15"/>
			<target ref="id24"/>
			<label kind="guard" x="-637" y="-68">start == ID</label>
			<label kind="assignment" x="-620" y="-51">t = 0</label>
			<nail x="-663" y="-34"/>
		</transition>
		<transition>
			<source ref="id20"/>
			<target ref="id22"/>
			<label kind="guard" x="59" y="-25">failures &gt;= tolerance</label>
			<label kind="assignment" x="102" y="-42">t = 0</label>
		</transition>
		<transition>
			<source ref="id20"/>
			<target ref="id18"/>
			<label kind="guard" x="-161" y="-34">failures &lt; tolerance</label>
			<label kind="assignment" x="-136" y="-17">t = 0</label>
			<nail x="-170" y="0"/>
		</transition>
		<transition>
			<source ref="id18"/>
			<target ref="id21"/>
			<label kind="guard" x="-144" y="102">t &gt;= 1 &amp;&amp; start != ID</label>
			<label kind="synchronisation" x="-144" y="119">transmit[nextHop()]!</label>
			<label kind="assignment" x="-144" y="136">sender = ID,
t = 0</label>
		</transition>
		<transition>
			<source ref="id15"/>
			<target ref="id23"/>
			<label kind="guard" x="-505" y="-98">isDead() == true</label>
		</transition>
		<transition>
			<source ref="id21"/>
			<target ref="id20"/>
			<label kind="guard" x="51" y="17">t &gt;= 5</label>
			<label kind="assignment" x="42" y="34">failures++,
totalFailures++</label>
		</transition>
		<transition>
			<source ref="id19"/>
			<target ref="id18"/>
			<label kind="guard" x="-263" y="102">t &gt;= 1</label>
			<label kind="synchronisation" x="-306" y="119">respond[senderID]!</label>
			<label kind="assignment" x="-263" y="136">t = 0</label>
		</transition>
		<transition>
			<source ref="id17"/>
			<target ref="id19"/>
			<label kind="synchronisation" x="-476" y="102">transmit[ID]?</label>
			<label kind="assignment" x="-476" y="119">senderID = sender,
CheckFailed(),
t = 0</label>
		</transition>
		<transition>
			<source ref="id15"/>
			<target ref="id17"/>
			<label kind="guard" x="-503" y="-1">start != ID &amp;&amp;
isDead() == false &amp;&amp;
isOutOfReach() == false</label>
		</transition>
	</template>
	<template>
		<name>FailureDetection</name>
		<declaration>UID Clockwise(int n)
{
  return n % N;
}

UID CounterClockwise(int n)
{
  if (n &lt; 0) { return N - 1; }
  else { return n; }

}</declaration>
		<location id="id30" x="-127" y="0">
			<committed/>
		</location>
		<location id="id31" x="136" y="0">
			<committed/>
		</location>
		<location id="id32" x="306" y="-68">
			<name x="272" y="-102">SingleSplit</name>
		</location>
		<location id="id33" x="374" y="68">
			<committed/>
		</location>
		<location id="id34" x="544" y="0">
			<name x="561" y="-8">Subdivided</name>
		</location>
		<location id="id35" x="544" y="136">
			<name x="561" y="127">Split</name>
		</location>
		<init ref="id30"/>
		<transition>
			<source ref="id33"/>
			<target ref="id35"/>
			<label kind="select" x="391" y="144">deadNode2: UID</label>
			<label kind="guard" x="391" y="161">deadNode2 == Clockwise(deadNodes[0] + 1)</label>
			<label kind="assignment" x="391" y="187">split = true,
subdivided = false,
deadNodes[1] = deadNode2</label>
			<nail x="374" y="136"/>
		</transition>
		<transition>
			<source ref="id33"/>
			<target ref="id34"/>
			<label kind="select" x="374" y="-178">deadNode2 : UID</label>
			<label kind="guard" x="374" y="-153">deadNode2 != start &amp;&amp;
deadNode2 != deadNodes[0] &amp;&amp;
deadNode2 != Clockwise(deadNodes[0] + 1) &amp;&amp;
deadNode2 != CounterClockwise(start - 1)</label>
			<label kind="assignment" x="374" y="-76">subdivided = true,
split = false,
deadNodes[1] = deadNode2</label>
			<nail x="374" y="0"/>
		</transition>
		<transition>
			<source ref="id31"/>
			<target ref="id33"/>
			<label kind="assignment" x="161" y="76">singleSplit = false</label>
			<nail x="136" y="68"/>
		</transition>
		<transition>
			<source ref="id31"/>
			<target ref="id32"/>
			<label kind="assignment" x="161" y="-93">singleSplit = true</label>
			<nail x="136" y="-68"/>
		</transition>
		<transition>
			<source ref="id30"/>
			<target ref="id31"/>
			<label kind="select" x="-127" y="-110">startNode : UID,
deadNode1 : UID</label>
			<label kind="guard" x="-127" y="-76">deadNode1 == Clockwise(startNode + 1)</label>
			<label kind="assignment" x="-127" y="-59">start = startNode,
deadNodes[0] = deadNode1</label>
		</transition>
	</template>
	<system>system RingNodeSync, FailureDetection;
    </system>
	<queries>
		<query>
			<formula>******** SYNC QUEURIES *******</formula>
			<comment></comment>
		</query>
		<query>
			<formula></formula>
			<comment></comment>
		</query>
		<query>
			<formula>A[] comms &lt;= (N - 2) * 2</formula>
			<comment></comment>
		</query>
		<query>
			<formula>E&lt;&gt; comms &lt; N &amp;&amp; (forall (i : UID) RingNodeSync(i).Split || RingNodeSync(i).Subdivided || RingNodeSync(i).Dead || RingNodeSync(i).OutOfReach) </formula>
			<comment></comment>
		</query>
		<query>
			<formula></formula>
			<comment></comment>
		</query>
		<query>
			<formula>A[] totalFailures &lt;= 3</formula>
			<comment></comment>
		</query>
		<query>
			<formula>E&lt;&gt; totalFailures &lt;= 2 &amp;&amp; (forall (i : UID) RingNodeSync(i).Split || RingNodeSync(i).Subdivided || RingNodeSync(i).Dead || RingNodeSync(i).OutOfReach) </formula>
			<comment></comment>
		</query>
		<query>
			<formula></formula>
			<comment></comment>
		</query>
		<query>
			<formula>A[] forall (i : UID) RingNodeSync(i).Done imply time &lt;= (N * 2) + 1</formula>
			<comment></comment>
		</query>
		<query>
			<formula>A[] forall (i : UID) RingNodeSync(i).Done imply RingNodeSync(i).t &lt;= N</formula>
			<comment></comment>
		</query>
		<query>
			<formula></formula>
			<comment></comment>
		</query>
		<query>
			<formula>FailureDetection.Subdivided  --&gt; (forall (i : UID) RingNodeSync(i).Dead || RingNodeSync(i).OutOfReach || RingNodeSync(i).Subdivided)</formula>
			<comment></comment>
		</query>
		<query>
			<formula>FailureDetection.Split       --&gt; (forall (i : UID) RingNodeSync(i).Dead || RingNodeSync(i).Split)</formula>
			<comment></comment>
		</query>
		<query>
			<formula>FailureDetection.SingleSplit --&gt; (forall (i : UID) RingNodeSync(i).Dead || RingNodeSync(i).Split) </formula>
			<comment></comment>
		</query>
		<query>
			<formula></formula>
			<comment></comment>
		</query>
		<query>
			<formula></formula>
			<comment></comment>
		</query>
		<query>
			<formula>A[] forall (i : UID) RingNodeSync(i).Dead imply deadNodes[0] == i || deadNodes[1] == i</formula>
			<comment></comment>
		</query>
		<query>
			<formula></formula>
			<comment></comment>
		</query>
		<query>
			<formula>A&lt;&gt; forall (i: UID) RingNodeSync(i).Dead || RingNodeSync(i).OutOfReach || RingNodeSync(i).Split || RingNodeSync(i).Subdivided</formula>
			<comment></comment>
		</query>
		<query>
			<formula></formula>
			<comment></comment>
		</query>
		<query>
			<formula>******** ASYNC QUEURIES *******</formula>
			<comment></comment>
		</query>
		<query>
			<formula></formula>
			<comment></comment>
		</query>
		<query>
			<formula>A[] comms &lt;= (N - 2) * 2</formula>
			<comment></comment>
		</query>
		<query>
			<formula>E&lt;&gt; comms &gt; (N - 2) * 2 &amp;&amp; (forall (i : UID) RingNodeAsync(i).Split || RingNodeAsync(i).Subdivided || RingNodeAsync(i).Dead || RingNodeAsync(i).OutOfReach) </formula>
			<comment></comment>
		</query>
		<query>
			<formula></formula>
			<comment></comment>
		</query>
		<query>
			<formula>A[] totalFailures &lt;= ((N - 1) * 4) - 1</formula>
			<comment></comment>
		</query>
		<query>
			<formula>E&lt;&gt; totalFailures &gt; ((N - 1) * 4) - 1 &amp;&amp; (forall (i : UID) RingNodeAsync(i).Split || RingNodeAsync(i).Subdivided || RingNodeAsync(i).Dead || RingNodeAsync(i).OutOfReach) </formula>
			<comment></comment>
		</query>
		<query>
			<formula></formula>
			<comment></comment>
		</query>
		<query>
			<formula>A&lt;&gt; FailureDetection.Subdivided	  imply forall (i : UID) (RingNodeAsync(i).Dead &amp;&amp; (deadNodes[0] == i || deadNodes[1] == i)) || RingNodeAsync(i).Subdivided || RingNodeAsync(i).OutOfReach </formula>
			<comment></comment>
		</query>
		<query>
			<formula>A&lt;&gt; FailureDetection.Split       imply forall (i : UID) (RingNodeAsync(i).Dead &amp;&amp; (deadNodes[0] == i || deadNodes[1] == i)) || RingNodeAsync(i).Split </formula>
			<comment></comment>
		</query>
		<query>
			<formula>A&lt;&gt; FailureDetection.SingleSplit imply forall (i : UID) (RingNodeAsync(i).Dead &amp;&amp; deadNodes[0] == i) || RingNodeAsync(i).Split </formula>
			<comment></comment>
		</query>
		<query>
			<formula></formula>
			<comment></comment>
		</query>
		<query>
			<formula></formula>
			<comment></comment>
		</query>
		<query>
			<formula>******** DEADLOCK QUEURIES *******</formula>
			<comment></comment>
		</query>
		<query>
			<formula></formula>
			<comment></comment>
		</query>
		<query>
			<formula>E&lt;&gt; deadlock &amp;&amp; forall (i : UID) (!RingNodeSync(i).Split &amp;&amp; !RingNodeSync(i).Subdivided) || RingNodeSync(i).Dead || RingNodeSync(i).OutOfReach</formula>
			<comment></comment>
		</query>
		<query>
			<formula>E&lt;&gt; deadlock &amp;&amp; forall (i : UID) (!RingNodeAsync(i).Split &amp;&amp; !RingNodeAsync(i).Subdivided) || RingNodeAsync(i).Dead || RingNodeAsync(i).OutOfReach</formula>
			<comment></comment>
		</query>
		<query>
			<formula>E&lt;&gt; deadlock</formula>
			<comment></comment>
		</query>
		<query>
			<formula></formula>
			<comment></comment>
		</query>
		<query>
			<formula></formula>
			<comment></comment>
		</query>
		<query>
			<formula>******** DEBUG QUEURIES *******</formula>
			<comment></comment>
		</query>
		<query>
			<formula></formula>
			<comment></comment>
		</query>
		<query>
			<formula>A&lt;&gt; forall (i : UID) RingNodeSync(i).Split  || RingNodeSync(i).Subdivided  || RingNodeSync(i).Dead  || RingNodeSync(i).OutOfReach </formula>
			<comment></comment>
		</query>
		<query>
			<formula>A&lt;&gt; forall (i : UID) RingNodeAsync(i).Split || RingNodeAsync(i).Subdivided || RingNodeAsync(i).Dead || RingNodeAsync(i).OutOfReach </formula>
			<comment></comment>
		</query>
		<query>
			<formula></formula>
			<comment></comment>
		</query>
		<query>
			<formula>E&lt;&gt; forall (i : UID) RingNodeSync(i).Split  || RingNodeSync(i).Subdivided  || RingNodeSync(i).Dead  || RingNodeSync(i).OutOfReach </formula>
			<comment></comment>
		</query>
		<query>
			<formula>E&lt;&gt; forall (i : UID) RingNodeAsync(i).Split || RingNodeAsync(i).Subdivided || RingNodeAsync(i).Dead || RingNodeAsync(i).OutOfReach </formula>
			<comment></comment>
		</query>
		<query>
			<formula></formula>
			<comment></comment>
		</query>
		<query>
			<formula>A&lt;&gt; forall (i : UID) start == i imply RingNodeSync(i).Split  || RingNodeSync(i).Subdivided</formula>
			<comment></comment>
		</query>
		<query>
			<formula>A&lt;&gt; forall (i : UID) start == i imply RingNodeAsync(i).Split || RingNodeAsync(i).Subdivided</formula>
			<comment></comment>
		</query>
		<query>
			<formula></formula>
			<comment></comment>
		</query>
		<query>
			<formula>E&lt;&gt; forall (i : UID) start == i imply RingNodeSync(i).Split  || RingNodeSync(i).Subdivided</formula>
			<comment></comment>
		</query>
		<query>
			<formula>E&lt;&gt; forall (i : UID) start == i imply RingNodeAsync(i).Split || RingNodeAsync(i).Subdivided</formula>
			<comment></comment>
		</query>
		<query>
			<formula></formula>
			<comment></comment>
		</query>
		<query>
			<formula></formula>
			<comment></comment>
		</query>
	</queries>
</nta>
